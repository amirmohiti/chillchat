# CBot.py â€” ChillChat Community Bot (Webhook + FastAPI/Uvicorn)
# python-telegram-bot==20.3, fastapi, uvicorn
# Ø³Ø§Ø²Ú¯Ø§Ø± Ø¨Ø§ Python 3.13 â€” Ø¨Ø¯ÙˆÙ† JobQueueØ› Ø§Ø² asyncio Ø§Ø³ØªÙØ§Ø¯Ù‡ Ù…ÛŒâ€ŒÚ©Ù†Ø¯

import os
import json
import re
import asyncio
from datetime import datetime
from contextlib import asynccontextmanager

from fastapi import FastAPI, Request
from telegram import (
    Update,
    InlineKeyboardButton, InlineKeyboardMarkup,
    ReplyKeyboardMarkup, KeyboardButton,
)
from telegram.ext import (
    ApplicationBuilder, ContextTypes, CommandHandler,
    CallbackQueryHandler, MessageHandler, filters,
)

# =========================
#          CONFIG
# =========================
BOT_TOKEN = os.environ.get("BOT_TOKEN")
WEBHOOK_URL = os.environ.get("WEBHOOK_URL")
GROUP_CHAT_ID = int(os.environ.get("GROUP_CHAT_ID", "0"))  # Ú¯Ø±ÙˆÙ‡ Ø§Ø¯Ù…ÛŒÙ†/Ø¯ÛŒØªØ§Ø³Ù†ØªØ±
DATACENTER_CHAT_ID = int(os.environ.get("DATACENTER_CHAT_ID", str(GROUP_CHAT_ID or 0)))  # Ø§Ú¯Ø± Ø¬Ø¯Ø§Ø³Øª Ø³Øª Ú©Ù†

SUPPORT_USERNAME = os.environ.get("SUPPORT_USERNAME", "ifyoulostme")
CHANNEL_URL = os.environ.get("CHANNEL_URL", "")
GROUP_URL   = os.environ.get("GROUP_URL", "")
INSTAGRAM_URL = os.environ.get("INSTAGRAM_URL", "")
CAFE_INTRO_USERNAME = os.environ.get("CAFE_INTRO_USERNAME", "ifyoulostme")  # Ø¨Ø±Ø§ÛŒ Â«Ù…Ø¹Ø±ÙÛŒ Ú©Ø§ÙÙ‡Â»

# (Optional) Google Sheets
GSPREAD_CREDS_JSON = os.environ.get("GSPREAD_CREDS_JSON")
SHEET_NAME = os.environ.get("SHEET_NAME", "EnglishClubRegistrations")

# ØªØ§ÛŒÛŒØ¯ Ø®ÙˆØ¯Ú©Ø§Ø± Ù¾Ø³ Ø§Ø² 12 Ø³Ø§Ø¹Øª
AUTO_APPROVE_DELAY = 12 * 60 * 60  # 43200 Ø«Ø§Ù†ÛŒÙ‡

# Ù†Ù…Ø§ÛŒØ´ JSON Ø¯Ø± Ù¾ÛŒØ§Ù… Ù¾ÛŒÙ†â€ŒØ´Ø¯Ù‡ØŸ (Ù¾ÛŒØ´â€ŒÙØ±Ø¶ Ø®Ø§Ù…ÙˆØ´)
SHOW_JSON_IN_PINNED = os.environ.get("SHOW_JSON_IN_PINNED", "0") == "1"

# Ø³Ù‚Ù Ø¢Ù‚Ø§ÛŒØ§Ù† Ø¯Ø± Ù‡Ø± Ø±ÙˆÛŒØ¯Ø§Ø¯
MALE_LIMIT_PER_EVENT = int(os.environ.get("MALE_LIMIT_PER_EVENT", "5"))

# --- DEFAULT EVENTS (override via EVENTS_JSON) ---
DEFAULT_EVENTS = [
    {
        "id": "intro01",
        "title": "2nd Meeting!",
        "when": "Ù¾Ù†Ø¬Ø´Ù†Ø¨Ù‡ Û± Ø¢Ø¨Ø§Ù†- Û±Û¸:Û°Û°",
        "price": "Ø³ÙØ§Ø±Ø´ Ø§Ø² Ú©Ø§ÙÙ‡",
        "capacity": 12,
        "desc": "The legendary 2nd session. It's all gonna be about chill & chat. btw topic will be decided in the group. stay tuned!",
    }
]
try:
    EVENTS = json.loads(os.environ.get("EVENTS_JSON", "")) or DEFAULT_EVENTS
    if not isinstance(EVENTS, list):
        EVENTS = DEFAULT_EVENTS
except Exception:
    EVENTS = DEFAULT_EVENTS

try:
    MEETUP_LINKS = json.loads(os.environ.get("MEETUP_LINKS_JSON", "{}"))
except Exception:
    MEETUP_LINKS = {}

# =========================
#     IN-MEMORY STORAGE
# =========================
# PENDING: Ø¯Ø±Ø®ÙˆØ§Ø³Øªâ€ŒÙ‡Ø§ÛŒ Ø¯Ø± Ø§Ù†ØªØ¸Ø§Ø± ØªØ§ÛŒÛŒØ¯
# Ù‡Ø± ÙˆØ±ÙˆØ¯ÛŒ: {name, phone, level, note, gender, age, event_id, event_title, when, username, admin_msg_id, task}
PENDING = {}  # key: user_chat_id -> dict
# ROSTER: Ø§ÙØ±Ø§Ø¯ ØªØ§ÛŒÛŒØ¯Ø´Ø¯Ù‡ Ø¨Ù‡ ØªÙÚ©ÛŒÚ© Ø±ÙˆÛŒØ¯Ø§Ø¯
# Ù‡Ø± Ø¢ÛŒØªÙ…: {name, username, phone, gender, age, when, event_title}
ROSTER = {}   # key: event_id -> list[dict]
ROSTER_MESSAGE_ID = None  # Ù¾ÛŒØ§Ù… Ù¾ÛŒÙ†â€ŒØ´Ø¯Ù‡ Ø¯ÛŒØªØ§Ø³Ù†ØªØ±

# =========================
#          TEXTS
# =========================
reply_main = ReplyKeyboardMarkup([["Ø´Ø±ÙˆØ¹ Ù…Ø¬Ø¯Ø¯ ğŸ”„"]], resize_keyboard=True)

WELCOME = (
    "Ø³Ù„Ø§Ù…! Ø¨Ù‡ *ChillChat Community* Ø®ÙˆØ´ Ø§ÙˆÙ…Ø¯ÛŒ â˜•ğŸ‡¬ğŸ‡§\n"
    "Ø§ÛŒÙ†Ø¬Ø§ Ù…ÛŒâ€ŒØªÙˆÙ†ÛŒ Ø±ÙˆÛŒØ¯Ø§Ø¯Ù‡Ø§ÛŒ Ø²Ø¨Ø§Ù† Ø§Ù†Ú¯Ù„ÛŒØ³ÛŒ Ø±Ùˆ Ø¨Ø¨ÛŒÙ†ÛŒ Ùˆ Ø«Ø¨Øªâ€ŒÙ†Ø§Ù… Ú©Ù†ÛŒ."
)

FAQ = (
    "â” **Ø³ÙˆØ§Ù„Ø§Øª Ù…ØªØ¯Ø§ÙˆÙ„ Ø¯Ø±Ø¨Ø§Ø±Ù‡ ChillChat**\n\n"
    "ğŸ—£ï¸ **Ø¯Ø± Ø¬Ù„Ø³Ø§Øª Ú†ÛŒ Ú©Ø§Ø± Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ…ØŸ**\n"
    "Ø¨Ø§ Ø¨Ù‚ÛŒÙ‡ Ø¨Ù‡ Ø§Ù†Ú¯Ù„ÛŒØ³ÛŒ ØµØ­Ø¨Øª Ù…ÛŒâ€ŒÚ©Ù†ÛŒØŒ Ø¨Ø§Ø²ÛŒ Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ…ØŒ Ù…ÙˆØ¶ÙˆØ¹â€ŒÙ‡Ø§ÛŒ Ø±ÙˆØ² Ø±Ùˆ ØªÙ…Ø±ÛŒÙ† Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ…ØŒ Ùˆ Ú©Ù„ÛŒ Ø¢Ø´Ù†Ø§Ù‡Ø§ÛŒ Ø¬Ø¯ÛŒØ¯ Ù¾ÛŒØ¯Ø§ Ù…ÛŒâ€ŒÚ©Ù†ÛŒ!\n\n"
    "â˜• **Ú©Ø¬Ø§ Ø¨Ø±Ú¯Ø²Ø§Ø± Ù…ÛŒâ€ŒØ´Ù†ØŸ**\n"
    "Ø¬Ù„Ø³Ø§Øª Ø¯Ø± Ú©Ø§ÙÙ‡ Ø¨Ø±Ú¯Ø²Ø§Ø± Ù…ÛŒâ€ŒØ´Ù† Ùˆ Ø¨Ø±Ø§ÛŒ Ù‡Ù…Ù‡ Ø³Ø·ÙˆØ­ Ø¨Ø§Ø²Ù†.\n\n"
    "ğŸ’¶ **Ù‡Ø²ÛŒÙ†Ù‡ Ø´Ø±Ú©Øª Ú†Ù‚Ø¯Ø±Ù‡ØŸ**\n"
    "Ø±ÙˆÛŒØ¯Ø§Ø¯Ù‡Ø§ Ù…Ø¹Ù…ÙˆÙ„Ø§Ù‹ Ø±Ø§ÛŒÚ¯Ø§Ù† Ù‡Ø³ØªÙ†Ø› ÙÙ‚Ø· Ù„Ø§Ø²Ù…Ù‡ ÛŒÚ© Ø³ÙØ§Ø±Ø´ Ø§Ø² Ú©Ø§ÙÙ‡ Ø¯Ø§Ø´ØªÙ‡ Ø¨Ø§Ø´ÛŒ.\n\n"
    "ğŸ“¸ **Ø¹Ú©Ø³â€ŒØ¨Ø±Ø¯Ø§Ø±ÛŒ**\n"
    "Ú¯Ø§Ù‡ÛŒ Ø¨Ù„Ù‡â€”Ø¨Ø§ Ø±Ø¶Ø§ÛŒØª Ø´Ø±Ú©Øªâ€ŒÚ©Ù†Ù†Ø¯Ù‡â€ŒÙ‡Ø§ Ø¨Ø±Ø§ÛŒ Ø´Ø¨Ú©Ù‡â€ŒÙ‡Ø§ÛŒ Ø§Ø¬ØªÙ…Ø§Ø¹ÛŒ.\n\n"
    "ğŸ“ **Ø«Ø¨Øªâ€ŒÙ†Ø§Ù…**\n"
    "Ø¯Ø±Ø®ÙˆØ§Ø³ØªØª Ø¨Ø±Ø§ÛŒ Ø§Ø¯Ù…ÛŒÙ† Ø§Ø±Ø³Ø§Ù„ Ù…ÛŒØ´Ù‡ Ùˆ Ø¨Ø¹Ø¯ Ø§Ø² ØªØ§ÛŒÛŒØ¯ØŒ Ø§Ø³Ù…Øª Ø¯Ø± Ù„ÛŒØ³Øª Ø´Ø±Ú©Øªâ€ŒÚ©Ù†Ù†Ø¯Ú¯Ø§Ù† Ù‚Ø±Ø§Ø± Ù…ÛŒâ€ŒÚ¯ÛŒØ±Ù‡."
)

RULES = (
    "âš ï¸ **Ù‚ÙˆØ§Ù†ÛŒÙ† ChillChat**\n\n"
    "ğŸ’¬ Ø¨Ø§ Ø§Ø­ØªØ±Ø§Ù… Ø±ÙØªØ§Ø± Ú©Ù†.\n"
    "ğŸ—£ï¸ ØªØ§ Ø¬Ø§ÛŒ Ù…Ù…Ú©Ù† Ø§Ù†Ú¯Ù„ÛŒØ³ÛŒ ØµØ­Ø¨Øª Ú©Ù† (Ù‡Ø¯ÙÙ…ÙˆÙ† ØªÙ…Ø±ÛŒÙ†Ù‡).\n"
    "â° Ø¨Ù‡â€ŒÙ…ÙˆÙ‚Ø¹ Ø¨ÛŒØ§Ø› Ø´Ø±ÙˆØ¹ Ø¯Ù‚ÛŒÙ‚.\n"
    "ğŸ“± Ú¯ÙˆØ´ÛŒ Ø¨ÛŒâ€ŒØµØ¯Ø§.\n"
    "ğŸ™ Ø§Ú¯Ø± Ù†Ù…ÛŒâ€ŒØªÙˆÙ†ÛŒ Ø´Ø±Ú©Øª Ú©Ù†ÛŒØŒ Ø²ÙˆØ¯ØªØ± Ø§Ø·Ù„Ø§Ø¹ Ø¨Ø¯Ù‡.\n\n"
    "Ø¨Ø§ Ø±Ø¹Ø§ÛŒØª Ø§ÛŒÙ† Ù…ÙˆØ§Ø±Ø¯ØŒ ØªØ¬Ø±Ø¨Ù‡Ù” Ø¨Ù‡ØªØ±ÛŒ Ø®ÙˆØ§Ù‡ÛŒÙ… Ø¯Ø§Ø´Øª â˜•â¤ï¸"
)

# Ù…Ø¹Ø±ÙÛŒ Ú©Ø§ÙÙ‡ â€” Ù…ØªÙ† Ú©Ø§Ù…Ù„
CAFE_INTRO_TEXT = (
   "Ø§Ø³Ù… Ùˆ Ø¢Ø¯Ø±Ø³ Ú©Ø§ÙÙ‡ Ù…ÙˆØ±Ø¯ Ø¹Ù„Ø§Ù‚Ù‡â€ŒØª Ø±Ùˆ Ø¨Ø±Ø§ÛŒ @ifyoulostme Ø¨ÙØ±Ø³Øª"
)

# Ù¾ÛŒØ§Ù…â€ŒÙ‡Ø§ÛŒ Ø¸Ø±ÙÛŒØª
CAPACITY_CANCEL_MSG = (
    "âŒ Ø«Ø¨Øªâ€ŒÙ†Ø§Ù… Ø´Ù…Ø§ Ø¨Ù‡ Ø¯Ù„ÛŒÙ„ *ØªÚ©Ù…ÛŒÙ„ Ø¸Ø±ÙÛŒØª* Ù„ØºÙˆ Ø´Ø¯.\n"
    "Ø¨Ø±Ø§ÛŒ Ø´Ø±Ú©Øª Ø¯Ø± Ø¨Ø±Ù†Ø§Ù…Ù‡â€ŒÙ‡Ø§ÛŒ Ø¨Ø¹Ø¯ÛŒØŒ Ø§Ø² Â«ğŸ‰ Ø±ÙˆÛŒØ¯Ø§Ø¯Ù‡Ø§ÛŒ Ù¾ÛŒØ´â€ŒØ±ÙˆÂ» Ø±ÙˆÛŒØ¯Ø§Ø¯ Ø¯ÛŒÚ¯Ø±ÛŒ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†ÛŒØ¯."
)
CAPACITY_FULL_PREVENT_MSG = "âŒ Ø¸Ø±ÙÛŒØª Ø§ÛŒÙ† Ø±ÙˆÛŒØ¯Ø§Ø¯ ØªÚ©Ù…ÛŒÙ„ Ø§Ø³Øª. Ù„Ø·ÙØ§Ù‹ Ø±ÙˆÛŒØ¯Ø§Ø¯ Ø¯ÛŒÚ¯Ø±ÛŒ Ø±Ø§ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†."
MALE_CAPACITY_FULL_MSG = "âŒ Ø³Ù‚Ù Ø¸Ø±ÙÛŒØª Ø´Ø±Ú©Øªâ€ŒÚ©Ù†Ù†Ø¯Ú¯Ø§Ù† Ø¨Ø±Ø§ÛŒ Ø§ÛŒÙ† Ø±ÙˆÛŒØ¯Ø§Ø¯ ØªÚ©Ù…ÛŒÙ„ Ø´Ø¯Ù‡ Ø§Ø³Øª."

def SOCIAL_TEXT():
    return (
        "ğŸŒ **Ù…Ø§ Ø±Ø§ Ø¯Ø± Ø´Ø¨Ú©Ù‡â€ŒÙ‡Ø§ÛŒ Ø§Ø¬ØªÙ…Ø§Ø¹ÛŒ Ø¯Ù†Ø¨Ø§Ù„ Ú©Ù†:**\n\n"
        + (f"ğŸ“¢ [Ú©Ø§Ù†Ø§Ù„ ØªÙ„Ú¯Ø±Ø§Ù…]({CHANNEL_URL})\n" if CHANNEL_URL else "")
        + (f"ğŸ’¬ [Ú¯Ø±ÙˆÙ‡ ØªÙ„Ú¯Ø±Ø§Ù…]({GROUP_URL})\n" if GROUP_URL else "")
        + (f"ğŸ“¸ [Ø§ÛŒÙ†Ø³ØªØ§Ú¯Ø±Ø§Ù…]({INSTAGRAM_URL})\n" if INSTAGRAM_URL else "")
        + ("\nØ¨Ø²ÙˆØ¯ÛŒ Ù„ÛŒÙ†Ú©â€ŒÙ‡Ø§ ØªÚ©Ù…ÛŒÙ„ Ù…ÛŒâ€ŒØ´ÙˆÙ†Ø¯." if not (CHANNEL_URL or GROUP_URL or INSTAGRAM_URL) else "")
    )

# =========================
#          HELPERS
# =========================
def get_event(ev_id):
    return next((e for e in EVENTS if e.get("id") == ev_id), None)

def approved_count(ev_id: str) -> int:
    return len(ROSTER.get(ev_id, []))

def remaining_capacity(ev: dict) -> int:
    cap = int(ev.get("capacity", 0) or 0)
    return max(0, cap - approved_count(ev["id"])) if cap else 999999

def male_count(ev_id: str) -> int:
    return sum(1 for r in ROSTER.get(ev_id, []) if r.get("gender") == "male")

def event_text_user(ev):
    # Ø¨Ø¯ÙˆÙ† Ù†Ù…Ø§ÛŒØ´ Ø¸Ø±ÙÛŒØª
    parts = [
        f"**{ev.get('title','')}**",
        f"ğŸ•’ {ev.get('when','')}",
        f"ğŸ“ {ev.get('place','â€”')}",
        f"ğŸ’¶ {ev.get('price','') or 'Free'}",
    ]
    if ev.get("desc"):  parts.append(f"ğŸ“ {ev['desc']}")
    parts.append("\n(Ø¢Ø¯Ø±Ø³ Ø¯Ù‚ÛŒÙ‚ Ú©Ø§ÙÙ‡ Ù¾ÛŒØ´ Ø§Ø² Ø±ÙˆÛŒØ¯Ø§Ø¯ Ø¯Ø± ChillChat Official Ø§Ø¹Ù„Ø§Ù… Ù…ÛŒâ€ŒØ´ÙˆØ¯.)")
    return "\n".join(parts)

def event_text_admin(ev):
    # Ø¨Ø±Ø§ÛŒ Ø§Ø¯Ù…ÛŒÙ† â€” Ø¨Ø§ Ø¸Ø±ÙÛŒØª
    cap_line = ""
    if ev.get("capacity"):
        cap_line = f"ğŸ‘¥ Ø¸Ø±ÙÛŒØª: {approved_count(ev['id'])}/{ev['capacity']}\n"
    return (
        f"ğŸ“Œ {ev.get('title','')}\n"
        f"ğŸ•’ {ev.get('when','')}\n"
        f"{cap_line}"
        f"ğŸ“ {ev.get('place','â€”')}\n"
        f"ğŸ—ºï¸ {ev.get('maps','â€”')}\n"
        f"ğŸ’¶ {ev.get('price','Free')}\n"
        f"ğŸ“ {ev.get('desc','â€”')}"
    )

def push_step(context, step):
    nav = context.user_data.get("nav", [])
    nav.append(step)
    context.user_data["nav"] = nav

def pop_step(context):
    nav = context.user_data.get("nav", [])
    if nav: nav.pop()
    context.user_data["nav"] = nav
    return nav[-1] if nav else None

def current_step(context):
    nav = context.user_data.get("nav", [])
    return nav[-1] if nav else None

def clear_flow(context):
    for k in ["nav","origin","selected_event_id","name","phone","level","gender","age","note","feedback_mode"]:
        context.user_data.pop(k, None)

# ====== Datacenter pinned message (human text; JSON optional) ======
def _build_human_roster_text():
    if not ROSTER:
        return "ğŸ“‹ Ù„ÛŒØ³Øª ØªØ§ÛŒÛŒØ¯Ø´Ø¯Ù‡â€ŒÙ‡Ø§ (DataCenter)\nâ€” Ù‡Ù†ÙˆØ² Ú©Ø³ÛŒ ØªØ§ÛŒÛŒØ¯ Ù†Ø´Ø¯Ù‡."
    lines = ["ğŸ“‹ Ù„ÛŒØ³Øª ØªØ§ÛŒÛŒØ¯Ø´Ø¯Ù‡â€ŒÙ‡Ø§ (DataCenter)"]
    for ev in EVENTS:
        ev_id = ev["id"]
        people = ROSTER.get(ev_id, [])
        lines.append(f"\nğŸ—“ {ev['title']} â€” {ev['when']} | ØªØ§ÛŒÛŒØ¯Ø´Ø¯Ù‡â€ŒÙ‡Ø§: {len(people)} (Ø¢Ù‚Ø§ÛŒØ§Ù†: {male_count(ev_id)})")
        if not people:
            lines.append("  â€” Ù‡Ù†ÙˆØ² ØªØ§ÛŒÛŒØ¯ÛŒ Ù†Ø¯Ø§Ø±ÛŒÙ…")
        else:
            for i, r in enumerate(people, start=1):
                uname = f"@{r['username']}" if r.get("username") else "â€”"
                phone = r.get("phone","â€”")
                lines.append(f"  {i}. {r['name']} | {uname} | {phone}")
    return "\n".join(lines)

async def save_state_to_pinned(application):
    """
    Ù…ØªÙ† Ø®Ù„Ø§ØµÙ‡ Ø±Ø§ Ø¯Ø± Ù¾ÛŒØ§Ù… Ù¾ÛŒÙ†â€ŒØ´Ø¯Ù‡ Ø¯ÛŒØªØ§Ø³Ù†ØªØ± Ø¢Ù¾Ø¯ÛŒØª Ù…ÛŒâ€ŒÚ©Ù†Ø¯.
    Ø§Ú¯Ø± SHOW_JSON_IN_PINNED=1 Ø¨Ø§Ø´Ø¯ØŒ JSON Ù‡Ù… Ø¶Ù…ÛŒÙ…Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯.
    """
    global ROSTER_MESSAGE_ID
    if not DATACENTER_CHAT_ID:
        return

    human = _build_human_roster_text()
    if SHOW_JSON_IN_PINNED:
        human += "\n\n---\n```json\n" + json.dumps(
            {"events":[{"id":e["id"],"capacity":e.get("capacity"),"title":e["title"],"when":e["when"]} for e in EVENTS],
             "roster":ROSTER}, ensure_ascii=False) + "\n```"

    try:
        if ROSTER_MESSAGE_ID:
            await application.bot.edit_message_text(
                chat_id=DATACENTER_CHAT_ID,
                message_id=ROSTER_MESSAGE_ID,
                text=human,
            )
            return
    except Exception as e:
        print("edit pinned roster failed, will recreate:", e)

    try:
        msg = await application.bot.send_message(chat_id=DATACENTER_CHAT_ID, text=human)
        ROSTER_MESSAGE_ID = msg.message_id
        try:
            await application.bot.pin_chat_message(
                chat_id=DATACENTER_CHAT_ID,
                message_id=ROSTER_MESSAGE_ID,
                disable_notification=True
            )
        except Exception as e:
            print("pin roster message failed:", e)
    except Exception as e:
        print("send roster message failed:", e)

async def _update_roster_message(context: ContextTypes.DEFAULT_TYPE):
    await save_state_to_pinned(context.application)

# =========================
#          UI
# =========================
def build_main_menu():
    buttons = [
        [InlineKeyboardButton("ğŸ‰ Ø±ÙˆÛŒØ¯Ø§Ø¯Ù‡Ø§ÛŒ Ù¾ÛŒØ´â€ŒØ±Ùˆ", callback_data="list_events")],
        [InlineKeyboardButton("ğŸ“ Ø«Ø¨Øªâ€ŒÙ†Ø§Ù… Ø³Ø±ÛŒØ¹", callback_data="register")],
        [InlineKeyboardButton("ğŸ  Ù…Ø¹Ø±ÙÛŒ Ú©Ø§ÙÙ‡", callback_data="cafe_intro")],
        [InlineKeyboardButton("ğŸŒ Ø´Ø¨Ú©Ù‡â€ŒÙ‡Ø§ÛŒ Ø§Ø¬ØªÙ…Ø§Ø¹ÛŒ", callback_data="socials")],
        [InlineKeyboardButton("â” Ø³ÙˆØ§Ù„Ø§Øª Ù…ØªØ¯Ø§ÙˆÙ„", callback_data="faq")],
        [InlineKeyboardButton("ğŸ†˜ Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ", callback_data="support")],
        [InlineKeyboardButton("ğŸ’¬ Ø§Ø±Ø³Ø§Ù„ Ù†Ø¸Ø± Ùˆ Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯", callback_data="feedback_start")],
    ]
    return InlineKeyboardMarkup(buttons)

def back_inline():
    return InlineKeyboardMarkup([[InlineKeyboardButton("â†©ï¸ Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ Ù…Ø±Ø­Ù„Ù‡ Ù‚Ø¨Ù„", callback_data="back_step")]])

def rules_inline():
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("âœ… Ù‚Ø¨ÙˆÙ„ Ø¯Ø§Ø±Ù… Ùˆ Ø¨Ø¹Ø¯ÛŒ", callback_data="accept_rules")],
        [InlineKeyboardButton("â†©ï¸ Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ Ù…Ø±Ø­Ù„Ù‡ Ù‚Ø¨Ù„", callback_data="back_step")],
    ])

def level_inline():
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("Beginner (A1â€“A2)", callback_data="lvl_A")],
        [InlineKeyboardButton("Intermediate (B1â€“B2)", callback_data="lvl_B")],
        [InlineKeyboardButton("Advanced (C1+)", callback_data="lvl_C")],
        [InlineKeyboardButton("â†©ï¸ Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ Ù…Ø±Ø­Ù„Ù‡ Ù‚Ø¨Ù„", callback_data="back_step")],
    ])

def gender_inline():
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("ğŸ‘¨ Ù…Ø±Ø¯", callback_data="gender_m"),
         InlineKeyboardButton("ğŸ‘© Ø²Ù†",  callback_data="gender_f")],
        [InlineKeyboardButton("ğŸ¤« ØªØ±Ø¬ÛŒØ­ Ù…ÛŒâ€ŒØ¯Ù‡Ù… Ù†Ú¯ÙˆÛŒÙ…", callback_data="gender_n")],
        [InlineKeyboardButton("â†©ï¸ Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ Ù…Ø±Ø­Ù„Ù‡ Ù‚Ø¨Ù„", callback_data="back_step")],
    ])

def age_inline():
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("â– ØªØ±Ø¬ÛŒØ­ Ù…ÛŒâ€ŒØ¯Ù‡Ù… Ù†Ú¯ÙˆÛŒÙ…", callback_data="age_na")],
        [InlineKeyboardButton("â†©ï¸ Ø¨Ø§Ø²Ú¯Ø´Øª Ø¨Ù‡ Ù…Ø±Ø­Ù„Ù‡ Ù‚Ø¨Ù„", callback_data="back_step")],
    ])

def event_inline_register(ev_id):
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("ğŸ“ Ø«Ø¨Øªâ€ŒÙ†Ø§Ù… Ø¯Ø± Ù‡Ù…ÛŒÙ† Ø±ÙˆÛŒØ¯Ø§Ø¯", callback_data=f"register_{ev_id}")],
        [InlineKeyboardButton("â†©ï¸ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data="back_home")],
    ])

# =========================
#        RENDERERS
# =========================
async def render_home(update: Update, context: ContextTypes.DEFAULT_TYPE, edit=False):
    clear_flow(context)
    if edit and update.callback_query:
        await update.callback_query.edit_message_text("ÛŒÚ©ÛŒ Ø§Ø² Ú¯Ø²ÛŒÙ†Ù‡â€ŒÙ‡Ø§ Ø±Ùˆ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†:", reply_markup=build_main_menu())
    else:
        if update.message:
            await update.message.reply_text(WELCOME, parse_mode="Markdown", reply_markup=reply_main)
            await update.message.reply_text("ÛŒÚ©ÛŒ Ø§Ø² Ú¯Ø²ÛŒÙ†Ù‡â€ŒÙ‡Ø§ Ø±Ùˆ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†:", reply_markup=build_main_menu())
        elif update.callback_query:
            await update.callback_query.edit_message_text("ÛŒÚ©ÛŒ Ø§Ø² Ú¯Ø²ÛŒÙ†Ù‡â€ŒÙ‡Ø§ Ø±Ùˆ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†:", reply_markup=build_main_menu())

async def render_event_list(update: Update):
    rows = []
    for e in EVENTS:
        # Ø¨Ø¯ÙˆÙ† Ù†Ù…Ø§ÛŒØ´ Ø¸Ø±ÙÛŒØª
        label = f"{e['title']} | {e['when']}"
        rows.append([InlineKeyboardButton(label, callback_data=f"event_{e['id']}")])
    rows.append([InlineKeyboardButton("â†©ï¸ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data="back_home")])
    await update.callback_query.edit_message_text("Ø±ÙˆÛŒØ¯Ø§Ø¯Ù‡Ø§ÛŒ Ù¾ÛŒØ´â€ŒØ±Ùˆ:", reply_markup=InlineKeyboardMarkup(rows))

async def render_event_detail(update: Update, ev):
    await update.callback_query.edit_message_text(
        event_text_user(ev), parse_mode="Markdown", reply_markup=event_inline_register(ev["id"])
    )

async def render_rules(update: Update, context: ContextTypes.DEFAULT_TYPE):
    push_step(context, "rules")
    if update.callback_query:
        await update.callback_query.edit_message_text(RULES, reply_markup=rules_inline())
    else:
        await update.message.reply_text(RULES, reply_markup=rules_inline())

async def render_name(update: Update, context: ContextTypes.DEFAULT_TYPE, edit=False):
    push_step(context, "name")
    txt = "Ù„Ø·ÙØ§Ù‹ *Ù†Ø§Ù… Ùˆ Ù†Ø§Ù… Ø®Ø§Ù†ÙˆØ§Ø¯Ú¯ÛŒ* Ø±Ùˆ ÙˆØ§Ø±Ø¯ Ú©Ù†:"
    if edit and update.callback_query:
        await update.callback_query.edit_message_text(txt, parse_mode="Markdown", reply_markup=back_inline())
    else:
        await update.effective_chat.send_message(txt, parse_mode="Markdown", reply_markup=back_inline())

async def render_gender(update: Update, context: ContextTypes.DEFAULT_TYPE, edit=False):
    push_step(context, "gender")
    txt = "Ø¬Ù†Ø³ÛŒØªØª Ø±Ùˆ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†:"
    if update.callback_query and edit:
        await update.callback_query.edit_message_text(txt, reply_markup=gender_inline())
    else:
        await update.effective_chat.send_message(txt, reply_markup=gender_inline())

async def render_age(update: Update, context: ContextTypes.DEFAULT_TYPE, edit=False):
    push_step(context, "age")
    txt = "Ø³Ù†â€ŒØª Ø±Ùˆ Ø¨Ù‡ *Ø¹Ø¯Ø¯* Ø¨ÙØ±Ø³Øª (Ù…Ø«Ù„Ø§Ù‹ 24). ÛŒØ§ Ø¯Ú©Ù…Ù‡Ù” Â«ØªØ±Ø¬ÛŒØ­ Ù…ÛŒâ€ŒØ¯Ù‡Ù… Ù†Ú¯ÙˆÛŒÙ…Â» Ø±Ùˆ Ø¨Ø²Ù†."
    if update.callback_query and edit:
        await update.callback_query.edit_message_text(txt, parse_mode="Markdown", reply_markup=age_inline())
    else:
        await update.effective_chat.send_message(txt, parse_mode="Markdown", reply_markup=age_inline())

async def render_level(update: Update, context: ContextTypes.DEFAULT_TYPE, edit=False):
    push_step(context, "level")
    if update.callback_query and edit:
        await update.callback_query.edit_message_text("Ø³Ø·Ø­ Ø²Ø¨Ø§Ù†Øª Ú†ÛŒÙ‡ØŸ ÛŒÚ©ÛŒ Ø±Ùˆ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†:", reply_markup=level_inline())
    else:
        await update.effective_chat.send_message("Ø³Ø·Ø­ Ø²Ø¨Ø§Ù†Øª Ú†ÛŒÙ‡ØŸ ÛŒÚ©ÛŒ Ø±Ùˆ Ø§Ù†ØªØ®Ø§Ø¨ Ú©Ù†:", reply_markup=level_inline())

async def render_phone(update: Update, context: ContextTypes.DEFAULT_TYPE):
    push_step(context, "phone")
    contact_btn = ReplyKeyboardMarkup(
        [[KeyboardButton("Ø§Ø±Ø³Ø§Ù„ Ø´Ù…Ø§Ø±Ù‡ ØªÙ…Ø§Ø³ ğŸ“±", request_contact=True)]],
        resize_keyboard=True, one_time_keyboard=True,
    )
    await update.effective_chat.send_message("Ø´Ù…Ø§Ø±Ù‡ ØªÙ„ÙÙ†Øª Ø±Ùˆ ÙˆØ§Ø±Ø¯ Ú©Ù† ÛŒØ§ Ø¯Ú©Ù…Ù‡ Ø²ÛŒØ± Ø±Ùˆ Ø¨Ø²Ù†:", reply_markup=contact_btn)
    await update.effective_chat.send_message("ÛŒØ§ Ù…ÛŒâ€ŒØªÙˆÙ†ÛŒ Ø¨Ù‡ Ù…Ø±Ø­Ù„Ù‡ Ù‚Ø¨Ù„ Ø¨Ø±Ú¯Ø±Ø¯ÛŒ:", reply_markup=back_inline())

async def render_note(update: Update, context: ContextTypes.DEFAULT_TYPE, edit=False):
    push_step(context, "note")
    txt = "ÛŒØ§Ø¯Ø¯Ø§Ø´Øª/Ù†ÛŒØ§Ø² Ø®Ø§Øµ Ø¯Ø§Ø±ÛŒØŸ (Ø§Ø®ØªÛŒØ§Ø±ÛŒ) Ø§ÛŒÙ†Ø¬Ø§ Ø¨Ù†ÙˆÛŒØ³ Ùˆ Ø¨ÙØ±Ø³Øª. Ø§Ú¯Ø± Ú†ÛŒØ²ÛŒ Ù†Ø¯Ø§Ø±ÛŒØŒ ÙÙ‚Ø· ÛŒÚ© Ø®Ø· ØªÛŒØ±Ù‡ `-` Ø¨ÙØ±Ø³Øª."
    if update.callback_query and edit:
        await update.callback_query.edit_message_text(txt, parse_mode="Markdown", reply_markup=back_inline())
    else:
        await update.effective_chat.send_message(txt, parse_mode="Markdown", reply_markup=back_inline())

async def go_back(update: Update, context: ContextTypes.DEFAULT_TYPE):
    pop_step(context)
    prev = current_step(context)
    origin = context.user_data.get("origin")
    sel_ev = get_event(context.user_data.get("selected_event_id"))

    if not prev:
        if origin == "event" and sel_ev and update.callback_query:
            return await render_event_detail(update, sel_ev)
        return await render_home(update, context, edit=True)

    if prev == "rules":
        await render_rules(update, context)
    elif prev == "name":
        await render_name(update, context, edit=True)
    elif prev == "gender":
        await render_gender(update, context, edit=True)
    elif prev == "age":
        await render_age(update, context, edit=True)
    elif prev == "level":
        await render_level(update, context, edit=True)
    elif prev == "phone":
        await render_phone(update, context)
    elif prev == "note":
        await render_note(update, context, edit=True)
    else:
        await render_home(update, context, edit=True)

# =========================
#         HANDLERS
# =========================
async def cmd_start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await render_home(update, context)

async def cmd_testpin(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        await save_state_to_pinned(context.application)
        await update.message.reply_text("âœ… Ù„ÛŒØ³Øª Ø´Ø±Ú©Øªâ€ŒÚ©Ù†Ù†Ø¯Ú¯Ø§Ù† Ø¯Ø± Ú¯Ø±ÙˆÙ‡ Ø¯ÛŒØªØ§Ø³Ù†ØªØ± Ø³Ø§Ø®ØªÙ‡/Ø¢Ù¾Ø¯ÛŒØª Ùˆ Ù¾ÛŒÙ† Ø´Ø¯.")
    except Exception as e:
        await update.message.reply_text(f"âš ï¸ Ø®Ø·Ø§ Ø¯Ø± Ù¾ÛŒÙ†/Ø¢Ù¾Ø¯ÛŒØª Ù„ÛŒØ³Øª: {e}")

async def cmd_roster(update: Update, context: ContextTypes.DEFAULT_TYPE):
    try:
        human = _build_human_roster_text()
        await update.message.reply_text("ğŸ“‹ ÙˆØ¶Ø¹ÛŒØª ÙØ¹Ù„ÛŒ (in-memory):\n\n" + human[:3800])
    except Exception as e:
        await update.message.reply_text(f"âš ï¸ Ø®Ø·Ø§ Ø¯Ø± Ù†Ù…Ø§ÛŒØ´ Ù„ÛŒØ³Øª: {e}")

async def shortcut_restart(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await render_home(update, context)

async def handle_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    q = update.callback_query
    data = q.data

    if data.startswith("lvl_"):
        return await handle_level(update, context)

    if data.startswith("gender_"):
        return await handle_gender(update, context)

    if data == "age_na":
        # Ø³Ù† = Ø§Ø¹Ù„Ø§Ù… Ù†Ù…ÛŒâ€ŒÚ©Ù†Ù…
        context.user_data["age"] = None
        await q.answer()
        return await render_level(update, context, edit=True)

    await q.answer()

    if data == "back_home":
        return await render_home(update, context, edit=True)
    if data == "back_step":
        return await go_back(update, context)

    if data == "faq":
        return await q.edit_message_text(FAQ, parse_mode="Markdown",
                                         reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("â†©ï¸ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data="back_home")]]))

    if data == "support":
        txt = f"ğŸ†˜ Ø¨Ø±Ø§ÛŒ Ù¾Ø´ØªÛŒØ¨Ø§Ù†ÛŒ Ø¨Ù‡ Ø¢ÛŒØ¯ÛŒ Ø²ÛŒØ± Ù¾ÛŒØ§Ù… Ø¨Ø¯Ù‡:\n@{SUPPORT_USERNAME}"
        return await q.edit_message_text(txt, reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("â†©ï¸ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data="back_home")]]))

    if data == "cafe_intro":
        return await q.edit_message_text(CAFE_INTRO_TEXT, parse_mode="Markdown",
                                         reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("â†©ï¸ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data="back_home")]]))

    if data == "socials":
        return await q.edit_message_text(SOCIAL_TEXT(), parse_mode="Markdown",
                                         reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("â†©ï¸ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data="back_home")]]))

    # === FIX: handle feedback_start so "Ø§Ø±Ø³Ø§Ù„ Ù†Ø¸Ø± Ùˆ Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯" Ú©Ø§Ø± Ú©Ù†Ø¯ ===
    if data == "feedback_start":
        # ÙØ¹Ø§Ù„â€ŒØ³Ø§Ø²ÛŒ Ø­Ø§Ù„Øª feedback Ø¯Ø± context.user_data
        context.user_data["feedback_mode"] = True
        # Ù¾ÛŒØ§Ù…ÛŒ Ú©Ù‡ Ø¨Ø±Ø§ÛŒ Ú©Ø§Ø±Ø¨Ø± Ù†Ø´Ø§Ù† Ø¯Ø§Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯ ØªØ§ Ù…ØªÙ†Ø´ Ø±Ø§ Ø§Ø±Ø³Ø§Ù„ Ú©Ù†Ø¯
        return await q.edit_message_text(
            "ğŸ“ Ù†Ø¸Ø±Øª Ø¯Ø±Ø¨Ø§Ø±Ù‡ Ø±ÙˆÛŒØ¯Ø§Ø¯Ù‡Ø§ØŒ Ù¾ÛŒØ´Ù†Ù‡Ø§Ø¯ Ø¨Ø±Ø§ÛŒ Ø¨Ù‡Ø¨ÙˆØ¯ØŒ ÛŒØ§ Ù‡Ø± Ø­Ø±Ù Ø¯ÛŒÚ¯Ù‡â€ŒØ§ÛŒ Ø±Ùˆ Ø¨Ù†ÙˆÛŒØ³ Ùˆ Ø¨ÙØ±Ø³Øª.\n"
            "Ù¾ÛŒØ§Ù…Øª Ù…Ø³ØªÙ‚ÛŒÙ… Ø¨Ø±Ø§ÛŒ ØªÛŒÙ… ChillChat Ø§Ø±Ø³Ø§Ù„ Ù…ÛŒØ´Ù‡ ğŸ’Œ",
            reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("â†©ï¸ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data="back_home")]])
        )

    if data == "list_events":
        return await render_event_list(update)

    if data.startswith("event_"):
        ev = get_event(data.split("_",1)[1])
        if not ev:
            return await q.answer("Ø§ÛŒÙ† Ø±ÙˆÛŒØ¯Ø§Ø¯ ÛŒØ§ÙØª Ù†Ø´Ø¯.", show_alert=True)
        return await render_event_detail(update, ev)

    if data == "register" or data.startswith("register_"):
        # Ø§Ù†ØªØ®Ø§Ø¨ Ø±ÙˆÛŒØ¯Ø§Ø¯
        target_ev = None
        if data.startswith("register_"):
            ev_id = data.split("_",1)[1]
            target_ev = get_event(ev_id)
            context.user_data["selected_event_id"] = ev_id
            context.user_data["origin"] = "event"
        else:
            context.user_data["origin"] = "menu"
            if not context.user_data.get("selected_event_id"):
                return await render_event_list(update)

        if not target_ev and context.user_data.get("selected_event_id"):
            target_ev = get_event(context.user_data["selected_event_id"])

        # Ø¸Ø±ÙÛŒØª Ú©Ù„ÛŒ Ø±ÙˆÛŒØ¯Ø§Ø¯
        if target_ev and target_ev.get("capacity") and remaining_capacity(target_ev) <= 0:
            return await q.edit_message_text(
                CAPACITY_FULL_PREVENT_MSG,
                reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("â†©ï¸ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data="back_home")]])
            )
        return await render_rules(update, context)

    if data == "accept_rules":
        return await render_name(update, context, edit=True)

    # Admin Approve / Reject
    if data.startswith("approve_") or data.startswith("reject_"):
        try:
            action, user_chat_id, ev_id = data.split("_", 2)
            user_chat_id = int(user_chat_id)
            ev = get_event(ev_id)
            approver = q.from_user
            approved_by = approver.full_name

            # Ø¸Ø±ÙÛŒØª Ú©Ù„ÛŒ Ø±ÙˆÛŒØ¯Ø§Ø¯
            if action == "approve" and ev and ev.get("capacity") and remaining_capacity(ev) <= 0:
                await q.answer("Ø¸Ø±ÙÛŒØª ØªÚ©Ù…ÛŒÙ„ Ø§Ø³ØªØ› Ø§Ù…Ú©Ø§Ù† ØªØ§ÛŒÛŒØ¯ Ù†ÛŒØ³Øª.", show_alert=True)
                base_text = q.message.text or ""
                stamp = "âš ï¸ ØªÙ„Ø§Ø´ Ø¨Ø±Ø§ÛŒ ØªØ§ÛŒÛŒØ¯ØŒ Ø§Ù…Ø§ Ø¸Ø±ÙÛŒØª ØªÚ©Ù…ÛŒÙ„ Ø§Ø³Øª."
                try:
                    await q.edit_message_text(base_text + "\n\n" + stamp)
                except:
                    pass
                return

            # Ø³Ù‚Ù Ø¢Ù‚Ø§ÛŒØ§Ù†
            info_preview = PENDING.get(user_chat_id, {})
            if action == "approve" and info_preview.get("gender") == "male":
                if male_count(ev_id) >= MALE_LIMIT_PER_EVENT:
                    await q.answer("Ø³Ù‚Ù Ø¢Ù‚Ø§ÛŒØ§Ù† ØªÚ©Ù…ÛŒÙ„ Ø§Ø³ØªØ› Ø§Ù…Ú©Ø§Ù† ØªØ§ÛŒÛŒØ¯ Ù†ÛŒØ³Øª.", show_alert=True)
                    base_text = q.message.text or ""
                    stamp = "âš ï¸ ØªÙ„Ø§Ø´ Ø¨Ø±Ø§ÛŒ ØªØ§ÛŒÛŒØ¯ Ø¢Ù‚Ø§ØŒ Ø§Ù…Ø§ Ø³Ù‚Ù Ø¢Ù‚Ø§ÛŒØ§Ù† ØªÚ©Ù…ÛŒÙ„ Ø§Ø³Øª."
                    try:
                        await q.edit_message_text(base_text + "\n\n" + stamp)
                    except:
                        pass
                    # Ø§Ø·Ù„Ø§Ø¹ Ø¨Ù‡ Ú©Ø§Ø±Ø¨Ø±:
                    try:
                        await context.bot.send_message(chat_id=user_chat_id, text=MALE_CAPACITY_FULL_MSG)
                    except:
                        pass
                    return

            # Ù¾ÛŒØ§Ù… Ø¨Ù‡ Ú©Ø§Ø±Ø¨Ø±
            if action == "approve":
                detail = (
                    "ğŸ‰ Ø«Ø¨Øªâ€ŒÙ†Ø§Ù…Øª ØªØ§ÛŒÛŒØ¯ Ø´Ø¯!\n\n"
                    f"ğŸ“Œ {ev.get('title','')}\n"
                    f"ğŸ•’ {ev.get('when','')}\n"
                    f"ğŸ“ {ev.get('place','â€”')}\n"
                    f"ğŸ—ºï¸ {ev.get('maps','â€”')}\n"
                    f"ğŸ’¶ {ev.get('price','Free')}\n"
                    f"ğŸ“ {ev.get('desc','â€”')}\n"
                ) if ev else "ğŸ‰ Ø«Ø¨Øªâ€ŒÙ†Ø§Ù…Øª ØªØ§ÛŒÛŒØ¯ Ø´Ø¯!"
                link = MEETUP_LINKS.get(ev_id)
                if link:
                    detail += f"\nğŸ”— Ù„ÛŒÙ†Ú© Ú¯Ø±ÙˆÙ‡/Ù‡Ù…Ø§Ù‡Ù†Ú¯ÛŒ:\n{link}"
                await context.bot.send_message(chat_id=user_chat_id, text=detail)
            else:
                await context.bot.send_message(chat_id=user_chat_id, text=CAPACITY_CANCEL_MSG)

            # Ø­Ø°Ù Ø¯Ú©Ù…Ù‡â€ŒÙ‡Ø§ + Ù…Ù‡Ø± ØªØ§ÛŒÛŒØ¯/Ø±Ø¯
            base_text = q.message.text or ""
            stamp = "âœ… ØªÙˆØ³Ø· {0} ØªØ§ÛŒÛŒØ¯ Ø´Ø¯.".format(approved_by) if action == "approve" else "âŒ ØªÙˆØ³Ø· {0} Ø±Ø¯ Ø´Ø¯.".format(approved_by)
            try:
                await q.edit_message_text(base_text + "\n\n" + stamp)
            except Exception:
                try:
                    await q.edit_message_reply_markup(reply_markup=None)
                except:
                    pass

            # Ù„ØºÙˆ ØªØ³Ú© auto-approve Ø§Ú¯Ø± ÙˆØ¬ÙˆØ¯ Ø¯Ø§Ø±Ø¯
            info = PENDING.get(user_chat_id)
            if info and info.get("task"):
                try:
                    info["task"].cancel()
                except Exception:
                    pass

            # Ø§Ù†ØªÙ‚Ø§Ù„ Ø¨Ù‡ ROSTER
            if action == "approve":
                info = PENDING.pop(user_chat_id, None)
                if info:
                    if ev and ev.get("capacity") and remaining_capacity(ev) <= 0:
                        await context.bot.send_message(chat_id=GROUP_CHAT_ID, text="âš ï¸ Ø¸Ø±ÙÛŒØª Ù¾Ø± Ø´Ø¯Ø› ØªØ§ÛŒÛŒØ¯ Ù†Ù‡Ø§ÛŒÛŒ Ø§Ù†Ø¬Ø§Ù… Ù†Ø´Ø¯.")
                    else:
                        # Ú†Ú© Ù…Ø¬Ø¯Ø¯ Ø³Ù‚Ù Ø¢Ù‚Ø§ÛŒØ§Ù†
                        if info.get("gender") == "male" and male_count(ev_id) >= MALE_LIMIT_PER_EVENT:
                            try:
                                await context.bot.send_message(chat_id=user_chat_id, text=MALE_CAPACITY_FULL_MSG)
                            except:
                                pass
                        else:
                            ROSTER.setdefault(ev_id, []).append({
                                "name": info.get("name","â€”"),
                                "username": info.get("username"),
                                "phone": info.get("phone","â€”"),
                                "gender": info.get("gender"),
                                "age": info.get("age"),
                                "when": info.get("when","â€”"),
                                "event_title": info.get("event_title","â€”"),
                            })
                            await _update_roster_message(context)

            await q.answer("Ø§Ù†Ø¬Ø§Ù… Ø´Ø¯.")
        except Exception as e:
            print("Admin callback error:", e)
            await q.answer("Ù…Ø´Ú©Ù„ÛŒ Ù¾ÛŒØ´ Ø§ÙˆÙ…Ø¯.", show_alert=True)
        return

async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = (update.message.text or "").strip()
    step = current_step(context)

    # Ø±ÛŒâ€ŒØ§Ø³ØªØ§Ø±Øª Ù…Ù†Ø¹Ø·Ù
    if re.fullmatch(r"Ø´Ø±ÙˆØ¹\s*Ù…Ø¬Ø¯Ø¯(?:\s*ğŸ”„)?", text):
        return await render_home(update, context)

    # Feedback mode
    if context.user_data.get("feedback_mode"):
        try:
            if GROUP_CHAT_ID:
                user = update.effective_user
                header = f"ğŸ’¬ Ù¾ÛŒØ§Ù… Ø¬Ø¯ÛŒØ¯ Ø§Ø² Ú©Ø§Ø±Ø¨Ø± ChillChat:\nğŸ‘¤ Ù†Ø§Ù…: {user.full_name}\n" + (f"ğŸ†” @{user.username}\n" if user.username else "ğŸ†” â€”\n")
                await context.bot.send_message(chat_id=GROUP_CHAT_ID, text=header)
                try:
                    await context.bot.forward_message(
                        chat_id=GROUP_CHAT_ID,
                        from_chat_id=update.effective_chat.id,
                        message_id=update.message.message_id
                    )
                except Exception:
                    await context.bot.copy_message(
                        chat_id=GROUP_CHAT_ID,
                        from_chat_id=update.effective_chat.id,
                        message_id=update.message.message_id
                    )
            await update.message.reply_text("Ù…Ù…Ù†ÙˆÙ† Ø§Ø² Ø¨Ø§Ø²Ø®ÙˆØ±Ø¯Øª ğŸ’› Ù¾ÛŒØ§Ù… ØªÙˆ Ø¨Ø±Ø§ÛŒ ØªÛŒÙ… ChillChat Ø§Ø±Ø³Ø§Ù„ Ø´Ø¯.", reply_markup=reply_main)
        finally:
            context.user_data["feedback_mode"] = False
        return

    # Registration flow (ØªØ±ØªÛŒØ¨ Ø¬Ø¯ÛŒØ¯)
    if step == "name":
        if 2 <= len(text) <= 60:
            context.user_data["name"] = text
            return await render_gender(update, context, edit=False)
        else:
            return await update.message.reply_text("Ù„Ø·ÙØ§Ù‹ Ù†Ø§Ù… Ù…Ø¹ØªØ¨Ø± ÙˆØ§Ø±Ø¯ Ú©Ù† (Û² ØªØ§ Û¶Û° Ú©Ø§Ø±Ø§Ú©ØªØ±).")

    if step == "age":
        # Ø³Ù†: Ø¹Ø¯Ø¯ 1..120 ÛŒØ§ Ø¨Ø§ Ø¯Ú©Ù…Ù‡ Â«ØªØ±Ø¬ÛŒØ­ Ù…ÛŒâ€ŒØ¯Ù‡Ù… Ù†Ú¯ÙˆÛŒÙ…Â» Ø¯Ø± Ú©Ø§Ù„Ø¨Ú©
        if text == "-" or text == "â€”":
            context.user_data["age"] = None
        else:
            if not re.fullmatch(r"\d{1,3}", text):
                return await update.message.reply_text("Ù„Ø·ÙØ§Ù‹ Ø³Ù† Ø±Ø§ Ø¨Ù‡ Ø¹Ø¯Ø¯ ÙˆØ§Ø±Ø¯ Ú©Ù† (Ù…Ø«Ù„Ø§Ù‹ 23) ÛŒØ§ Ø§Ø² Ø¯Ú©Ù…Ù‡ Â«ØªØ±Ø¬ÛŒØ­ Ù…ÛŒâ€ŒØ¯Ù‡Ù… Ù†Ú¯ÙˆÛŒÙ…Â» Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†.")
            age_int = int(text)
            if not (1 <= age_int <= 120):
                return await update.message.reply_text("Ø³Ù† Ù†Ø§Ù…Ø¹ØªØ¨Ø± Ø§Ø³Øª. ÛŒÚ© Ø¹Ø¯Ø¯ Ø¨ÛŒÙ† 1 ØªØ§ 120 Ø¨ÙØ±Ø³Øª ÛŒØ§ Ø±ÙˆÛŒ Â«ØªØ±Ø¬ÛŒØ­ Ù…ÛŒâ€ŒØ¯Ù‡Ù… Ù†Ú¯ÙˆÛŒÙ…Â» Ø¨Ø²Ù†.")
            context.user_data["age"] = age_int
        return await render_level(update, context, edit=False)

    if step == "level":
        # Ø§ÛŒÙ† Ù…Ø±Ø­Ù„Ù‡ Ø¨Ø§ Ú©Ù„ÛŒØ¯Ù‡Ø§ÛŒ inline Ú©Ù†ØªØ±Ù„ Ù…ÛŒâ€ŒØ´ÙˆØ¯Ø› Ø§Ú¯Ø± Ú©Ø³ÛŒ Ù…ØªÙ† ÙØ±Ø³ØªØ§Ø¯ØŒ Ù†Ø§Ø¯ÛŒØ¯Ù‡ Ù…ÛŒâ€ŒÚ¯ÛŒØ±ÛŒÙ… Ùˆ Ø¯ÙˆØ¨Ø§Ø±Ù‡ Ù…Ù†Ùˆ Ù…ÛŒâ€ŒØ¯Ù‡ÛŒÙ…
        return await render_level(update, context, edit=False)

    if step == "phone":
        context.user_data["phone"] = text
        await update.message.reply_text("Ø´Ù…Ø§Ø±Ù‡ Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯ âœ…", reply_markup=reply_main)
        return await render_note(update, context, edit=False)

    if step == "note":
        context.user_data["note"] = text
        return await finalize_and_send(update, context)

    # ÙØ§Ù„Ø¨Ú©
    return await render_home(update, context)

async def handle_contact(update: Update, context: ContextTypes.DEFAULT_TYPE):
    if current_step(context) == "phone":
        context.user_data["phone"] = update.message.contact.phone_number
        await update.message.reply_text("Ø´Ù…Ø§Ø±Ù‡ Ø¯Ø±ÛŒØ§ÙØª Ø´Ø¯ âœ…", reply_markup=reply_main)
        await render_note(update, context, edit=False)

async def handle_level(update: Update, context: ContextTypes.DEFAULT_TYPE):
    q = update.callback_query
    data = q.data
    await q.answer()
    lvl_map = {"lvl_A": "Beginner (A1â€“A2)", "lvl_B": "Intermediate (B1â€“B2)", "lvl_C": "Advanced (C1+)"}
    context.user_data["level"] = lvl_map.get(data, "Unknown")
    # Ø¨Ø¹Ø¯ Ø§Ø² Ø³Ø·Ø­ Ø²Ø¨Ø§Ù† â†’ Ø´Ù…Ø§Ø±Ù‡ ØªÙ…Ø§Ø³
    await render_phone(update, context)

async def handle_gender(update: Update, context: ContextTypes.DEFAULT_TYPE):
    q = update.callback_query
    data = q.data  # gender_m / gender_f / gender_n
    await q.answer()
    gmap = {"gender_m": "male", "gender_f": "female", "gender_n": "na"}
    gender = gmap.get(data, "na")
    context.user_data["gender"] = gender

    # Ø§Ú¯Ø± Ú©Ø§Ø±Ø¨Ø± Â«Ù…Ø±Ø¯Â» Ø§Ø³Øª Ùˆ Ø³Ù‚Ù Ù¾Ø± Ø´Ø¯Ù‡ØŒ Ù‡Ù…ÛŒÙ†â€ŒØ¬Ø§ Ù‚Ø·Ø¹ Ú©Ù†ÛŒÙ…
    ev_id = context.user_data.get("selected_event_id") or (EVENTS[0]["id"] if EVENTS else None)
    if gender == "male" and ev_id and male_count(ev_id) >= MALE_LIMIT_PER_EVENT:
        await q.edit_message_text(MALE_CAPACITY_FULL_MSG,
                                  reply_markup=InlineKeyboardMarkup([[InlineKeyboardButton("â†©ï¸ Ø¨Ø§Ø²Ú¯Ø´Øª", callback_data="back_home")]]))
        clear_flow(context)
        return

    # Ø¨Ø¹Ø¯ Ø§Ø² Ø¬Ù†Ø³ÛŒØª â†’ Ø³Ù†
    await render_age(update, context, edit=True)

# =========================
#  AUTO-APPROVE via asyncio (12h)
# =========================
async def delayed_auto_approve(app, user_chat_id: int, ev_id: str, delay: int = AUTO_APPROVE_DELAY):
    try:
        await asyncio.sleep(delay)
    except asyncio.CancelledError:
        return
    info = PENDING.get(user_chat_id)
    if not info:
        return
    ev = get_event(ev_id)
    if not ev:
        PENDING.pop(user_chat_id, None)
        return

    # Ø¸Ø±ÙÛŒØª Ú©Ù„ÛŒ
    if ev.get("capacity") and remaining_capacity(ev) <= 0:
        try:
            await app.bot.send_message(chat_id=user_chat_id, text=CAPACITY_CANCEL_MSG)
        except Exception:
            pass
        try:
            if info.get("admin_msg_id"):
                await app.bot.delete_message(chat_id=GROUP_CHAT_ID, message_id=info["admin_msg_id"])
        except Exception:
            pass
        PENDING.pop(user_chat_id, None)
        return

    # Ø³Ù‚Ù Ø¢Ù‚Ø§ÛŒØ§Ù†
    if info.get("gender") == "male" and male_count(ev_id) >= MALE_LIMIT_PER_EVENT:
        try:
            await app.bot.send_message(chat_id=user_chat_id, text=MALE_CAPACITY_FULL_MSG)
        except Exception:
            pass
        try:
            if info.get("admin_msg_id"):
                await app.bot.delete_message(chat_id=GROUP_CHAT_ID, message_id=info["admin_msg_id"])
        except Exception:
            pass
        PENDING.pop(user_chat_id, None)
        return

    # add to roster
    ROSTER.setdefault(ev_id, []).append({
        "name": info.get("name","â€”"),
        "username": info.get("username"),
        "phone": info.get("phone","â€”"),
        "gender": info.get("gender"),
        "age": info.get("age"),
        "when": info.get("when","â€”"),
        "event_title": info.get("event_title","â€”"),
    })
    await save_state_to_pinned(app)

    # notify user
    detail = (
        "ğŸ‰ Ø«Ø¨Øªâ€ŒÙ†Ø§Ù…Øª ØªØ§ÛŒÛŒØ¯ Ø´Ø¯!\n\n"
        f"ğŸ“Œ {ev.get('title','')}\n"
        f"ğŸ•’ {ev.get('when','')}\n"
        f"ğŸ“ {ev.get('place','â€”')}\n"
        f"ğŸ—ºï¸ {ev.get('maps','â€”')}\n"
        f"ğŸ’¶ {ev.get('price','Free')}\n"
        f"ğŸ“ {ev.get('desc','â€”')}\n"
        "(Auto-approved by bot)"
    )
    link = MEETUP_LINKS.get(ev_id)
    if link:
        detail += f"\nğŸ”— Ù„ÛŒÙ†Ú© Ú¯Ø±ÙˆÙ‡/Ù‡Ù…Ø§Ù‡Ù†Ú¯ÛŒ:\n{link}"
    try:
        await app.bot.send_message(chat_id=user_chat_id, text=detail)
    except Exception:
        pass

    # delete admin message
    try:
        if info.get("admin_msg_id"):
            await app.bot.delete_message(chat_id=GROUP_CHAT_ID, message_id=info["admin_msg_id"])
    except Exception:
        pass

    PENDING.pop(user_chat_id, None)

# =========================
#   FINALIZE & SEND (to admin)
# =========================
async def finalize_and_send(update: Update, context: ContextTypes.DEFAULT_TYPE):
    u = context.user_data
    ev_id = u.get("selected_event_id") or (EVENTS[0]["id"] if EVENTS else None)
    ev = get_event(ev_id)

    # Ø¸Ø±ÙÛŒØª Ú©Ù„ÛŒ Ø±ÙˆÛŒØ¯Ø§Ø¯
    if ev and ev.get("capacity") and remaining_capacity(ev) <= 0:
        await update.effective_chat.send_message(CAPACITY_CANCEL_MSG, reply_markup=reply_main)
        clear_flow(context)
        return

    # Ø³Ù‚Ù Ø¢Ù‚Ø§ÛŒØ§Ù† (Ù¾ÛŒØ´ Ø§Ø² Ø§Ø±Ø³Ø§Ù„ Ø¨Ù‡ Ø§Ø¯Ù…ÛŒÙ†)
    if u.get("gender") == "male" and ev_id and male_count(ev_id) >= MALE_LIMIT_PER_EVENT:
        await update.effective_chat.send_message(MALE_CAPACITY_FULL_MSG, reply_markup=reply_main)
        clear_flow(context)
        return

    summary = (
        "âœ… Ø¯Ø±Ø®ÙˆØ§Ø³Øª Ø«Ø¨Øªâ€ŒÙ†Ø§Ù…Øª Ø«Ø¨Øª Ø´Ø¯ Ùˆ Ø¨Ø±Ø§ÛŒ Ø§Ø¯Ù…ÛŒÙ† Ø§Ø±Ø³Ø§Ù„ Ù…ÛŒâ€ŒØ´ÙˆØ¯.\n\n"
        f"ğŸ‘¤ Ù†Ø§Ù…: {u.get('name','â€”')}\n"
        f"âš§ Ø¬Ù†Ø³ÛŒØª: {({'male':'Ù…Ø±Ø¯','female':'Ø²Ù†','na':'ØªØ±Ø¬ÛŒØ­ Ù…ÛŒâ€ŒØ¯Ù‡Ù… Ù†Ú¯ÙˆÛŒÙ…'}).get(u.get('gender'),'â€”')}\n"
        f"ğŸ‚ Ø³Ù†: {u.get('age','â€”') if u.get('age') is not None else 'â€”'}\n"
        f"ğŸ—£ï¸ Ø³Ø·Ø­: {u.get('level','â€”')}\n"
        f"ğŸ“± ØªÙ…Ø§Ø³: {u.get('phone','â€”')}\n"
        f"ğŸ“ ØªÙˆØ¶ÛŒØ­Ø§Øª: {u.get('note','â€”')}\n"
    )
    if ev:
        summary += f"\nğŸ“Œ Ø±ÙˆÛŒØ¯Ø§Ø¯: {ev.get('title','')}\nğŸ•’ Ø²Ù…Ø§Ù†: {ev.get('when','')}\n(Ø¢Ø¯Ø±Ø³ Ù¾Ø³ Ø§Ø² ØªØ§ÛŒÛŒØ¯ Ø§Ø±Ø³Ø§Ù„ Ù…ÛŒâ€ŒØ´ÙˆØ¯.)"
    await update.effective_chat.send_message(summary, reply_markup=reply_main)

    # Send to admin group
    admin_msg = None
    if GROUP_CHAT_ID:
        user_chat_id = update.effective_chat.id
        approve_cb = f"approve_{user_chat_id}_{ev_id or 'NA'}"
        reject_cb = f"reject_{user_chat_id}_{ev_id or 'NA'}"
        buttons = InlineKeyboardMarkup([
            [InlineKeyboardButton("âœ… ØªØ§ÛŒÛŒØ¯", callback_data=approve_cb),
             InlineKeyboardButton("âŒ Ø±Ø¯", callback_data=reject_cb)]
        ])
        admin_txt = (
            "ğŸ”” Ø«Ø¨Øªâ€ŒÙ†Ø§Ù… Ø¬Ø¯ÛŒØ¯ ChillChat\n\n"
            f"ğŸ‘¤ Ù†Ø§Ù…: {u.get('name','â€”')}\n"
            f"âš§ Ø¬Ù†Ø³ÛŒØª: {({'male':'Ù…Ø±Ø¯','female':'Ø²Ù†','na':'ØªØ±Ø¬ÛŒØ­ Ù…ÛŒâ€ŒØ¯Ù‡Ù… Ù†Ú¯ÙˆÛŒÙ…'}).get(u.get('gender'),'â€”')}\n"
            f"ğŸ‚ Ø³Ù†: {u.get('age','â€”') if u.get('age') is not None else 'â€”'}\n"
            f"ğŸ—£ï¸ Ø³Ø·Ø­: {u.get('level','â€”')}\n"
            f"ğŸ“± ØªÙ…Ø§Ø³: {u.get('phone','â€”')}\n"
            f"ğŸ“ ØªÙˆØ¶ÛŒØ­Ø§Øª: {u.get('note','â€”')}\n\n"
        )
        if ev:
            admin_txt += event_text_admin(ev)
        admin_msg = await context.bot.send_message(chat_id=GROUP_CHAT_ID, text=admin_txt, reply_markup=buttons)

        # Save to pending + schedule auto-approve (12h) via asyncio
        task = context.application.create_task(
            delayed_auto_approve(context.application, user_chat_id, ev_id, delay=AUTO_APPROVE_DELAY)
        )
        PENDING[user_chat_id] = {
            "name": u.get('name','â€”'),
            "phone": u.get('phone','â€”'),
            "level": u.get('level','â€”'),
            "note":  u.get('note','â€”'),
            "gender": u.get('gender'),
            "age":    u.get('age'),
            "event_id": ev_id,
            "event_title": ev.get('title') if ev else "â€”",
            "when": ev.get('when') if ev else "â€”",
            "username": update.effective_user.username if update.effective_user else None,
            "admin_msg_id": admin_msg.message_id if admin_msg else None,
            "task": task,
        }

    await maybe_write_to_sheet(u, ev)
    clear_flow(context)

# =========================
#     Google Sheets (opt)
# =========================
async def maybe_write_to_sheet(user_info, ev):
    if not GSPREAD_CREDS_JSON:
        return
    try:
        import gspread
        from oauth2client.service_account import ServiceAccountCredentials
        scope = ['https://spreadsheets.google.com/feeds', 'https://www.googleapis.com/auth/drive']
        creds = ServiceAccountCredentials.from_json_keyfile_dict(json.loads(GSPREAD_CREDS_JSON), scope)
        client = gspread.authorize(creds)
        try:
            sh = client.open(SHEET_NAME)
        except Exception:
            sh = client.create(SHEET_NAME)
        ws = sh.sheet1
        try:
            if ws.get('A1:I1') == []:
                ws.update('A1:I1', [["Timestamp","Event","When","Name","Phone","Level","Gender","Age","Note"]])
        except Exception:
            pass
        now = datetime.utcnow().strftime('%Y-%m-%d %H:%M:%S')
        ws.append_row([
            now,
            (ev.get('title') if ev else 'â€”'),
            (ev.get('when') if ev else 'â€”'),
            user_info.get('name','â€”'),
            user_info.get('phone','â€”'),
            user_info.get('level','â€”'),
            ({'male':'Ù…Ø±Ø¯','female':'Ø²Ù†','na':'N/A'}).get(user_info.get('gender'),'â€”'),
            (user_info.get('age') if user_info.get('age') is not None else 'â€”'),
            user_info.get('note','â€”'),
        ])
    except Exception as e:
        print("Sheets error:", e)

# =========================
#     PTB + FastAPI APP
# =========================
if not BOT_TOKEN:
    raise RuntimeError("BOT_TOKEN is not set")

# Ù…Ù‡Ù…: JobQueue Ø±Ø§ Ø®Ø§Ù…ÙˆØ´ Ù…ÛŒâ€ŒÚ©Ù†ÛŒÙ… ØªØ§ Ø®Ø·Ø§ÛŒ weakref Ø¯Ø± Py 3.13 Ù¾ÛŒØ´ Ù†ÛŒØ§ÛŒØ¯
application = ApplicationBuilder().token(BOT_TOKEN).job_queue(None).build()

# Ù‡Ù†Ø¯Ù„Ø±Ù‡Ø§
application.add_handler(CommandHandler("start", cmd_start))
# Ø±ÛŒâ€ŒØ§Ø³ØªØ§Ø±Øª Ù…Ù†Ø¹Ø·Ù (Ø¨Ø§/Ø¨ÛŒ Ø§ÛŒÙ…ÙˆØ¬ÛŒ)
application.add_handler(MessageHandler(filters.TEXT & filters.Regex(r"^Ø´Ø±ÙˆØ¹\s*Ù…Ø¬Ø¯Ø¯(?:\s*ğŸ”„)?$"), shortcut_restart))

application.add_handler(CallbackQueryHandler(handle_level, pattern=r"^lvl_"))
application.add_handler(CallbackQueryHandler(handle_callback))
application.add_handler(MessageHandler(filters.CONTACT, handle_contact))
application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))
application.add_handler(CommandHandler("testpin", cmd_testpin))
application.add_handler(CommandHandler("roster",  cmd_roster))

@asynccontextmanager
async def lifespan(app: FastAPI):
    await application.initialize()
    if WEBHOOK_URL:
        await application.bot.set_webhook(url=WEBHOOK_URL)
    await application.start()
    yield
    await application.stop()
    await application.shutdown()

app = FastAPI(lifespan=lifespan)

@app.post("/")
async def webhook(request: Request):
    body = await request.json()
    update = Update.de_json(body, application.bot)
    await application.process_update(update)
    return {"status": "ok"}

@app.get("/")
async def root():
    return {"status": "ChillChat bot is running (12h auto-approve, hidden capacity, male cap=5)."}
