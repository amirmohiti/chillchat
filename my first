# =========================
# ChillChat Bot (CBot.py)
# Clean & Improved Version
# =========================
# Structure: Webhook + FastAPI
# Features: Registration Flow, Admin Approval, Feedback System
# Author: Based on original BigshotCrymax/Cbot
# Rewritten with bugfixes and cleanup by ChatGPT
# =========================

import os
import json
import asyncio
import logging
from datetime import datetime, timedelta

from fastapi import FastAPI, Request
from telegram import (
    InlineKeyboardButton, InlineKeyboardMarkup,
    Update, User, Message
)
from telegram.ext import (
    Application, CommandHandler, CallbackQueryHandler,
    ContextTypes, MessageHandler, filters
)
from telegram.constants import ParseMode

# Logging setup
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s",
    level=logging.INFO
)
logger = logging.getLogger(__name__)

# ======================
# Environment Variables
# ======================

BOT_TOKEN = os.getenv("BOT_TOKEN")
WEBHOOK_URL = os.getenv("WEBHOOK_URL")
ADMIN_CHAT_ID = int(os.getenv("ADMIN_CHAT_ID", "0"))
DATA_CENTER_CHAT_ID = int(os.getenv("DATA_CENTER_CHAT_ID", "0"))

MALE_LIMIT_PER_EVENT = int(os.getenv("MALE_LIMIT_PER_EVENT", "10"))
EVENT_CAPACITY = int(os.getenv("EVENT_CAPACITY", "25"))
AUTO_APPROVE_HOURS = int(os.getenv("AUTO_APPROVE_HOURS", "12"))
SHOW_JSON_IN_PINNED = os.getenv("SHOW_JSON_IN_PINNED", "0") == "1"

CHANNEL_LINK = os.getenv("CHANNEL_LINK", "https://t.me/chillchatcommunity")
GROUP_LINK = os.getenv("GROUP_LINK", "https://t.me/chillchatgroup")
INSTAGRAM_LINK = os.getenv("INSTAGRAM_LINK", "https://instagram.com/chillchat.iran")

# Admin Username (used in CAFE_INTRO)
CAFE_INTRO_USERNAME = os.getenv("CAFE_INTRO_USERNAME", "ifyoulostme")

# Events JSON
EVENTS_JSON = os.getenv("EVENTS_JSON", "[]")
try:
    EVENTS = json.loads(EVENTS_JSON)
except json.JSONDecodeError:
    EVENTS = []

# ======================
# In-Memory Data Storage
# ======================

PENDING = {}  # pending registrations
ROSTER = {}   # approved participants

# Each dict follows:
# PENDING[event_id][user_id] = {...user data...}
# ROSTER[event_id][user_id] = {...user data...}

# ======================
# Text Constants
# ======================

WELCOME_TEXT = (
    "👋 به ChillChat خوش اومدی!\n\n"
    "ما اینجا دورهمی‌های تمرین زبان انگلیسی برگزار می‌کنیم ☕️✨\n"
    "برای ثبت‌نام در رویداد بعدی، فقط کافیه گزینه زیر رو انتخاب کنی 👇"
)

MAIN_MENU = InlineKeyboardMarkup([
    [InlineKeyboardButton("📅 ثبت‌نام در رویداد", callback_data="register")],
    [InlineKeyboardButton("💬 ارسال نظر یا پیشنهاد", callback_data="feedback")],
    [InlineKeyboardButton("📍 معرفی کافه", callback_data="cafe_intro")],
    [
        InlineKeyboardButton("📢 کانال", url=CHANNEL_LINK),
        InlineKeyboardButton("👥 گروه", url=GROUP_LINK)
    ],
    [InlineKeyboardButton("📸 اینستاگرام", url=INSTAGRAM_LINK)],
])

# ======================
# Feedback Storage Flag
# ======================

# user_data["awaiting_feedback"] will be used to detect if the next message is feedback

# ======================
# بخش دوم: ثبت‌نام و تأیید ادمین
# ======================

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """شروع گفت‌وگو با کاربر"""
    await update.message.reply_text(WELCOME_TEXT, reply_markup=MAIN_MENU)


# ========== مرحله اول: شروع ثبت‌نام ==========
async def handle_register_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    # لیست رویدادها از ENV
    if not EVENTS:
        await query.edit_message_text("فعلاً رویدادی ثبت نشده 🚫")
        return

    keyboard = [
        [InlineKeyboardButton(event["name"], callback_data=f"event_{event['id']}")]
        for event in EVENTS
    ]
    await query.edit_message_text("یکی از رویدادها رو انتخاب کن 👇", reply_markup=InlineKeyboardMarkup(keyboard))


# ========== مرحله دوم: دریافت اطلاعات ==========
async def handle_event_selection(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    event_id = query.data.split("_")[1]
    context.user_data["event_id"] = event_id

    await query.edit_message_text(
        "👤 لطفاً نام و نام خانوادگی‌ت رو بنویس:"
    )
    context.user_data["register_step"] = "name"


async def handle_registration_steps(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """مدیریت مراحل ثبت‌نام کاربر"""
    user = update.effective_user
    text = update.message.text
    step = context.user_data.get("register_step")

    if not step:
        return

    # مرحله دریافت نام
    if step == "name":
        context.user_data["name"] = text
        context.user_data["register_step"] = "gender"
        await update.message.reply_text("👫 جنسیتت رو بنویس (مثلاً: مرد / زن):")
        return

    # مرحله دریافت جنسیت
    if step == "gender":
        context.user_data["gender"] = text.lower()
        context.user_data["register_step"] = "age"
        await update.message.reply_text("🎂 سنت چقدره؟")
        return

    # مرحله دریافت سن
    if step == "age":
        context.user_data["age"] = text
        context.user_data["register_step"] = "level"
        await update.message.reply_text("📚 سطح زبانت چقدره؟ (مثلاً: Intermediate)")
        return

    # مرحله دریافت سطح زبان
    if step == "level":
        context.user_data["level"] = text
        context.user_data["register_step"] = "phone"
        await update.message.reply_text("📞 شماره تماس (یا آیدی تلگرام) رو بنویس:")
        return

    # مرحله دریافت شماره
    if step == "phone":
        context.user_data["phone"] = text
        context.user_data["register_step"] = "note"
        await update.message.reply_text("📝 یادداشت یا توضیح اضافه‌ای داری؟ (در صورت نداشتن، بنویس: - )")
        return

    # مرحله نهایی: ارسال برای ادمین
    if step == "note":
        context.user_data["note"] = text
        event_id = context.user_data["event_id"]

        # ساخت دیتای کاربر
        user_data = {
            "id": user.id,
            "name": context.user_data["name"],
            "gender": context.user_data["gender"],
            "age": context.user_data["age"],
            "level": context.user_data["level"],
            "phone": context.user_data["phone"],
            "note": context.user_data["note"],
            "timestamp": datetime.now().isoformat()
        }

        if event_id not in PENDING:
            PENDING[event_id] = {}
        PENDING[event_id][user.id] = user_data

        await send_to_admin(context, event_id, user_data)
        await update.message.reply_text("درخواستت ارسال شد ✅ منتظر تأیید ادمین باش 🙌")

        context.user_data.clear()


# ========== ارسال به ادمین ==========
async def send_to_admin(context, event_id, user_data):
    """ارسال درخواست ثبت‌نام به گروه دیتاسنتر برای تأیید"""
    text = (
        f"🆕 <b>درخواست جدید</b>\n"
        f"👤 {user_data['name']}\n"
        f"⚧ {user_data['gender']}\n"
        f"🎂 {user_data['age']}\n"
        f"📚 {user_data['level']}\n"
        f"📞 {user_data['phone']}\n"
        f"📝 {user_data['note']}\n\n"
        f"<b>رویداد:</b> {get_event_name(event_id)}"
    )

    keyboard = InlineKeyboardMarkup([
        [
            InlineKeyboardButton("✅ تأیید", callback_data=f"approve_{event_id}_{user_data['id']}"),
            InlineKeyboardButton("❌ رد", callback_data=f"reject_{event_id}_{user_data['id']}")
        ]
    ])

    await context.bot.send_message(
        chat_id=DATA_CENTER_CHAT_ID,
        text=text,
        reply_markup=keyboard,
        parse_mode=ParseMode.HTML
    )


# ========== تأیید و رد ==========
async def handle_admin_decision(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    data = query.data.split("_")
    action, event_id, user_id = data[0], data[1], int(data[2])

    if event_id not in PENDING or user_id not in PENDING[event_id]:
        await query.edit_message_text("⛔️ این درخواست دیگه در صف نیست.")
        return

    user_data = PENDING[event_id].pop(user_id)

    if action == "approve":
        if check_capacity_limit(event_id, user_data):
            if event_id not in ROSTER:
                ROSTER[event_id] = {}
            ROSTER[event_id][user_id] = user_data
            await query.edit_message_text(f"✅ {user_data['name']} تأیید شد.")
            await notify_user(context, user_id, True, event_id)
        else:
            await query.edit_message_text("🚫 ظرفیت پر شده یا محدودیت رعایت نشده.")
            await notify_user(context, user_id, False, event_id)
    elif action == "reject":
        await query.edit_message_text(f"❌ {user_data['name']} رد شد.")
        await notify_user(context, user_id, False, event_id)


def check_capacity_limit(event_id, user_data):
    """بررسی ظرفیت کلی و محدودیت جنسیت"""
    roster = ROSTER.get(event_id, {})
    if len(roster) >= EVENT_CAPACITY:
        return False

    if user_data["gender"] == "مرد":
        male_count = sum(1 for u in roster.values() if u["gender"] == "مرد")
        if male_count >= MALE_LIMIT_PER_EVENT:
            return False

    return True


def get_event_name(event_id):
    for e in EVENTS:
        if str(e["id"]) == str(event_id):
            return e["name"]
    return "رویداد نامشخص"


async def notify_user(context, user_id, approved, event_id):
    """اطلاع به کاربر پس از تصمیم ادمین"""
    if approved:
        msg = f"🎉 ثبت‌نامت در {get_event_name(event_id)} تأیید شد! منتظرت هستیم 🙌"
    else:
        msg = f"متأسفانه در {get_event_name(event_id)} تأیید نشدی 😔"
    try:
        await context.bot.send_message(chat_id=user_id, text=msg)
    except Exception as e:
        logger.warning(f"Failed to notify user {user_id}: {e}")
# ======================
# بخش سوم: feedback, auto-approve, وبهوک و راه‌اندازی
# ======================

# متن معرفی کافه (اگر در بخش‌های قبلی تعریف نشده باشد)
CAFE_INTRO_TEXT = f"اسم و آدرس کافه مورد علاقه‌ت رو برای @{CAFE_INTRO_USERNAME} بفرست"

# ---------- Feedback (ارسال نظر و پیشنهاد) ----------
async def handle_feedback_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """وقتی کاربر روی دکمه‌ی feedback کلیک می‌کند — حالت دریافت بازخورد فعال می‌شود."""
    q = update.callback_query
    await q.answer()
    # ویرایش پیام منو و نمایش راهنما
    try:
        await q.edit_message_text(
            "مرسی که می‌خوای بازخورد بدی! ✍️\n\n"
            "لطفاً پیام یا پیشنهادت رو اینجا بنویس و بفرست. بعد از ارسال، پیام برای تیم ادمین ارسال می‌شه."
        )
    except Exception:
        # اگر ادیت پیام ناموفق بود، فقط یک پیام برای کاربر ارسال کن
        await q.message.reply_text(
            "مرسی که می‌خوای بازخورد بدی! ✍️\n\n"
            "لطفاً پیام یا پیشنهادت رو اینجا بنویس و بفرست. بعد از ارسال، پیام برای تیم ادمین ارسال می‌شه."
        )
    # ست کردن پرچم در user_data تا پیام بعدی به عنوان بازخورد در نظر گرفته شود
    context.user_data["awaiting_feedback"] = True


async def process_incoming_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """
    هندلر متنی عمومی که هم برای مراحل ثبت‌نام و هم برای feedback استفاده می‌شود.
    این تابع باید با اولویت بعد از هندلرهای خاص callbackها ثبت شود.
    """
    # اگر کاربر در حالت ثبت‌نام است، مسیر ثبت‌نام را مدیریت کن
    if context.user_data.get("register_step"):
        return await handle_registration_steps(update, context)

    # اگر کاربر در حالت feedback هست، پیام را به ادمین بفرست
    if context.user_data.get("awaiting_feedback"):
        try:
            user = update.effective_user
            header = (
                f"💬 پیام جدید از کاربر ChillChat:\n"
                f"👤 نام: {user.full_name}\n"
                + (f"🆔 @{user.username}\n" if user.username else "🆔 —\n")
            )
            # ارسال هدر به گروه ادمین (DATA_CENTER_CHAT_ID)
            if DATA_CENTER_CHAT_ID:
                await context.bot.send_message(chat_id=DATA_CENTER_CHAT_ID, text=header)
                # تلاش برای فوروارد پیام؛ اگر نشد، کپی کن
                try:
                    await context.bot.forward_message(
                        chat_id=DATA_CENTER_CHAT_ID,
                        from_chat_id=update.effective_chat.id,
                        message_id=update.message.message_id
                    )
                except Exception:
                    await context.bot.copy_message(
                        chat_id=DATA_CENTER_CHAT_ID,
                        from_chat_id=update.effective_chat.id,
                        message_id=update.message.message_id
                    )
            # پاسخ به کاربر
            await update.message.reply_text("ممنون از بازخوردت 💛 پیام تو برای تیم ChillChat ارسال شد.", reply_markup=None)
        except Exception as e:
            logger.exception("Error while processing feedback message: %s", e)
            try:
                await update.message.reply_text("مشکلی پیش اومد در ارسال بازخورد — لطفاً بعداً امتحان کن.")
            except:
                pass
        finally:
            # پاک کردن حالت feedback
            context.user_data.pop("awaiting_feedback", None)
        return

    # در غیر این صورت، اگر نه ثبت‌نام نه feedback — پیام را نادیده بگیر یا منو را نمایش بده
    await render_home(update, context)


# ---------- Auto-approve (تایید خودکار پس از زمان مشخص) ----------
async def delayed_auto_approve(application, event_id: str, user_id: int, delay_hours: int = AUTO_APPROVE_HOURS):
    """
    اگر ادمین در بازه مشخص اقدامی نکرد، درخواست را خودکار تأیید می‌کند.
    این تابع توسط send_to_admin زمان‌بندی می‌شود و در صورت نیاز از PENDING استفاده می‌کند.
    """
    try:
        await asyncio.sleep(delay_hours * 3600)
    except asyncio.CancelledError:
        return

    # چک کن که درخواست هنوز در PENDING هست
    pending_for_event = PENDING.get(event_id, {})
    info = pending_for_event.get(user_id)
    if not info:
        return  # قبلاً تأیید/رد شده یا حذف شده

    # بررسی ظرفیت به‌روز
    roster_for_event = ROSTER.get(event_id, {})
    if len(roster_for_event) >= EVENT_CAPACITY:
        # ظرفیت پر شد؛ به کاربر اطلاع بده و حذفش کن
        try:
            await application.bot.send_message(chat_id=user_id, text="❌ ثبت‌نام شما به دلیل تکمیل ظرفیت لغو شد.")
        except Exception:
            pass
        # حذف پیام ادمین اگر وجود داشته
        try:
            admin_msg_id = info.get("admin_msg_id")
            if admin_msg_id and DATA_CENTER_CHAT_ID:
                await application.bot.delete_message(chat_id=DATA_CENTER_CHAT_ID, message_id=admin_msg_id)
        except Exception:
            pass
        PENDING[event_id].pop(user_id, None)
        return

    # سقف آقایان
    if info.get("gender") and info.get("gender").lower() in ("مرد", "male") :
        male_count = sum(1 for u in roster_for_event.values() if u.get("gender") and u.get("gender").lower() in ("مرد", "male"))
        if male_count >= MALE_LIMIT_PER_EVENT:
            try:
                await application.bot.send_message(chat_id=user_id, text=MALE_CAPACITY_FULL_MSG)
            except Exception:
                pass
            try:
                admin_msg_id = info.get("admin_msg_id")
                if admin_msg_id and DATA_CENTER_CHAT_ID:
                    await application.bot.delete_message(chat_id=DATA_CENTER_CHAT_ID, message_id=admin_msg_id)
            except Exception:
                pass
            PENDING[event_id].pop(user_id, None)
            return

    # همه چیز خوبه — اضافه کن به ROSTER و اطلاع بده
    ROSTER.setdefault(event_id, {})[user_id] = info
    # حذف از pending
    PENDING[event_id].pop(user_id, None)
    # بروزرسانی پیام پین‌شده (اگر دادی‌سنتر استفاده می‌کنی)
    try:
        await save_state_to_pinned(application)
    except Exception:
        pass

    # اطلاع به کاربر
    try:
        await application.bot.send_message(
            chat_id=user_id,
            text=f"🎉 ثبت‌نامت در {get_event_name(event_id)} به‌صورت خودکار تأیید شد! منتظرت هستیم 🙌"
        )
    except Exception:
        pass


# ---------- کمکی: ذخیره و پین پیام دیتاسنتر (نسخه ساده) ----------
async def save_state_to_pinned(application):
    """
    نسخه ساده برای به‌روزرسانی پیام پین‌شده در DATA_CENTER_CHAT_ID.
    """
    if not DATA_CENTER_CHAT_ID:
        return
    text = "📋 لیست شرکت‌کننده‌ها:\n"
    for ev in EVENTS:
        ev_id = ev.get("id")
        roster_for_event = ROSTER.get(ev_id, {})
        text += f"\n🗓 {ev.get('name','رویداد')} — {ev.get('when','—')} | {len(roster_for_event)} شرکت‌کننده\n"
        for uid, u in roster_for_event.items():
            uname = f"@{u.get('username')}" if u.get("username") else "—"
            phone = u.get("phone","—")
            text += f"  • {u.get('name','—')} | {uname} | {phone}\n"
    try:
        # برای سادگی: فقط ارسال یک پیام جدید (مدیریت پیام پین‌شده پیچیده‌تر است)
        msg = await application.bot.send_message(chat_id=DATA_CENTER_CHAT_ID, text=text)
        try:
            await application.bot.pin_chat_message(chat_id=DATA_CENTER_CHAT_ID, message_id=msg.message_id, disable_notification=True)
        except Exception:
            pass
    except Exception as e:
        logger.warning("save_state_to_pinned failed: %s", e)


# ---------- Handler برای معرفی کافه ----------
async def handle_cafe_intro_callback(update: Update, context: ContextTypes.DEFAULT_TYPE):
    q = update.callback_query
    await q.answer()
    try:
        await q.edit_message_text(CAFE_INTRO_TEXT)
    except Exception:
        await q.message.reply_text(CAFE_INTRO_TEXT)


# ---------- راه‌اندازی Application و FastAPI وبهوک ----------
if not BOT_TOKEN:
    raise RuntimeError("BOT_TOKEN is not set in environment")

# ساخت Application (سازگار با PTB جدید)
application = Application.builder().token(BOT_TOKEN).build()

# ثبت هندلرها
application.add_handler(CommandHandler("start", start))

# Callback handlers
application.add_handler(CallbackQueryHandler(handle_register_callback, pattern=r"^register$"))
application.add_handler(CallbackQueryHandler(handle_feedback_callback, pattern=r"^feedback$"))
application.add_handler(CallbackQueryHandler(handle_cafe_intro_callback, pattern=r"^cafe_intro$"))
# انتخاب رویدادها: pattern event_{id}
application.add_handler(CallbackQueryHandler(handle_event_selection, pattern=r"^event_"))
# Admin approve/reject
application.add_handler(CallbackQueryHandler(handle_admin_decision, pattern=r"^(approve_|reject_)"))

# پیام‌های ورودی متنی (ثبت‌نام / feedback / عمومی)
application.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, process_incoming_text))

# وبهوک با FastAPI
from contextlib import asynccontextmanager
from fastapi import FastAPI, Request

@asynccontextmanager
async def lifespan(app: FastAPI):
    # initialize application and set webhook (اگر WEBHOOK_URL ست شده)
    await application.initialize()
    if WEBHOOK_URL:
        try:
            await application.bot.set_webhook(url=WEBHOOK_URL)
            logger.info("Webhook set to %s", WEBHOOK_URL)
        except Exception as e:
            logger.exception("Setting webhook failed: %s", e)
    await application.start()
    yield
    await application.stop()
    await application.shutdown()

app = FastAPI(lifespan=lifespan)

@app.post("/")
async def webhook_endpoint(request: Request):
    body = await request.json()
    update = Update.de_json(body, application.bot)
    await application.process_update(update)
    return {"status": "ok"}

@app.get("/")
async def root():
    return {"status": "ChillChat bot is running."}

# ---------- نکته: زمان‌بندی auto-approve هنگام ارسال به ادمین ----------
# در send_to_admin (در بخش ۲) بهتر است task زمان‌بندی‌شده ایجاد شود:
#   task = application.create_task(delayed_auto_approve(application, event_id, user_id, delay_hours=AUTO_APPROVE_HOURS))
#   سپس task را در PENDING[event_id][user_id]["task"] ذخیره کن تا در صورت approve/reject قابل cancel باشد.
#
# اگر در send_to_admin اینکار را انجام دادی، مطمئن شو که هنگام approve/reject آن task را cancel می‌کنی:
#   if info.get("task"): info["task"].cancel()
#
# (این متن صرفاً راهنمایی است؛ اگر می‌خواهی من همین الان send_to_admin را در بخش ۲ بروز کنم تا task بسازد، اعلام کن.)
